import streamlit as st
import pandas as pd
import plotly.express as px
from streamlit_autorefresh import st_autorefresh
from datetime import datetime
import os

st.set_page_config(page_title="Dashboard de Seguridad Facial", layout="wide")
st.title("ğŸ›¡ï¸ Dashboard de Seguridad Facial - LAB PRO")

LOCKS_FILE = "locks.txt"
REFRESH_INTERVAL = 3000
DEFAULT_ALERT_SECONDS = 30

st_autorefresh(interval=REFRESH_INTERVAL, key="refresh")

# ==========================
# ğŸ” DIAGNÃ“STICO DEL ARCHIVO
# ==========================
st.sidebar.subheader("ğŸ“‚ DiagnÃ³stico del sistema")

if os.path.exists(LOCKS_FILE):
    st.sidebar.success("âœ… locks.txt encontrado")
    with open(LOCKS_FILE, "r", encoding="utf-8", errors="ignore") as f:
        raw_lines = f.readlines()
    st.sidebar.write(f"ğŸ“„ Total de lÃ­neas: {len(raw_lines)}")
    st.sidebar.write("ğŸ“Œ Primeras 5 lÃ­neas:")
    for l in raw_lines[:5]:
        st.sidebar.code(l)
else:
    st.sidebar.error("âŒ ERROR: locks.txt NO estÃ¡ en esta carpeta")

# ==========================
# ğŸ“¥ LECTOR LIMPIO DE LOGS
# ==========================
def load_data_txt(file_path=LOCKS_FILE):
    data = []
    try:
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                line = line.strip()

                if " - " in line:
                    name_part, datetime_part = line.split(" - ", 1)

                    timestamp = pd.to_datetime(
                        datetime_part.strip(),
                        errors="coerce",
                        format="%Y-%m-%d %H:%M:%S"
                    )

                    if pd.isna(timestamp):
                        continue  # IGNORA timestamps malos

                    data.append({
                        "name": name_part.strip(),
                        "timestamp": timestamp
                    })
    except:
        pass

    df = pd.DataFrame(data)

    # âœ… LIMPIEZA FINAL GARANTIZADA
    if not df.empty:
        df = df.dropna(subset=["timestamp"])
        df["timestamp"] = pd.to_datetime(df["timestamp"])
        df = df.sort_values(by="timestamp", ascending=False).reset_index(drop=True)

    return df

# ==========================
# ğŸ“Š DATAFRAME PRINCIPAL
# ==========================
df = load_data_txt()

st.subheader("ğŸ“‹ Registros de detecciones (ordenados correctamente)")
st.write(f"Registros vÃ¡lidos cargados: {len(df)}")
st.dataframe(df, use_container_width=True)

# ==========================
# âœ… ÃšLTIMA DETECCIÃ“N GLOBAL REAL
# ==========================
if not df.empty:
    last_detection = df.iloc[0]["timestamp"]
    st.metric("ğŸ•’ Ãšltima detecciÃ³n global REAL", last_detection)

# ==========================
# ğŸ“Š GRÃFICOS GENERALES
# ==========================
if not df.empty:
    df["hour"] = df["timestamp"].dt.hour
    df["date"] = df["timestamp"].dt.date

    col1, col2 = st.columns(2)

    with col1:
        hour_counts = df.groupby("hour").size().reset_index(name="count")
        fig_hour = px.bar(hour_counts, x="hour", y="count", title="Detecciones por Hora")
        st.plotly_chart(fig_hour, use_container_width=True)

    with col2:
        day_counts = df.groupby("date").size().reset_index(name="count")
        fig_day = px.line(day_counts, x="date", y="count", title="Detecciones por DÃ­a")
        st.plotly_chart(fig_day, use_container_width=True)

# ==========================
# ğŸš¦ SEMÃFORO MULTI PERSONA REAL
# ==========================
st.subheader("ğŸš¦ Estado de Seguridad por Persona (hora REAL)")

if not df.empty:
    now = pd.Timestamp(datetime.now())

    last_by_person = df.groupby("name")["timestamp"].max().reset_index()

    for _, row in last_by_person.iterrows():
        name = row["name"]
        last_time = row["timestamp"]
        diff_seconds = (now - last_time).total_seconds()

        if diff_seconds <= DEFAULT_ALERT_SECONDS:
            st.markdown(
                f"<h2 style='color:red'>ğŸ”´ {name} DETECTADO HACE {int(diff_seconds)}s</h2>",
                unsafe_allow_html=True
            )
        else:
            st.markdown(
                f"<h2 style='color:green'>ğŸŸ¢ {name} SEGURO ({int(diff_seconds)}s)</h2>",
                unsafe_allow_html=True
            )
else:
    st.warning("âš ï¸ AÃºn no hay detecciones registradas")

# ==========================
# ğŸ” ANÃLISIS INDIVIDUAL REAL
# ==========================
if not df.empty:
    st.subheader("ğŸ§ AnÃ¡lisis por Persona")

    selected_name = st.selectbox("Selecciona persona", df["name"].unique())

    filtered_df = df[df["name"] == selected_name]
    st.dataframe(filtered_df, use_container_width=True)

    if not filtered_df.empty:
        filtered_df["hour"] = filtered_df["timestamp"].dt.hour
        filtered_df["date"] = filtered_df["timestamp"].dt.date

        col3, col4 = st.columns(2)

        with col3:
            hour_counts_p = filtered_df.groupby("hour").size().reset_index(name="count")
            fig_h_p = px.bar(hour_counts_p, x="hour", y="count", title=f"{selected_name} por Hora")
            st.plotly_chart(fig_h_p, use_container_width=True)

        with col4:
            day_counts_p = filtered_df.groupby("date").size().reset_index(name="count")
            fig_d_p = px.line(day_counts_p, x="date", y="count", title=f"{selected_name} por DÃ­a")
            st.plotly_chart(fig_d_p, use_container_width=True)